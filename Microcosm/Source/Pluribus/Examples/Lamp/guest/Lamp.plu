/*
  Lamp Example Unum

  Remember when you would play with a two-way switch connected to a common
  lamp? You would flick one switch and your sibling would flick the other,
  turning the light on and off. This example creates an unum that represents
  such a circuit.

  Two or more stations on the net can share a lamp unum. Whenever any station
  types a return charater on the console, the state of the lamp is toggled - and
  a report of the new state is printed on everyone's terminal.

*/

// A lamp unum has one message, a request to toggle.
  export unit Lamp {

  package ec.pl.examples.lamp;

  import ec.pl.runtime.*;
  import ec.e.quake.TimeMachine;
  import ec.e.start.TimeQuake;
  import ec.e.start.Seismologist;
  import ec.e.file.EStdio;
  import ec.e.start.Vat;
  
// Kind declarations for unum, presence, and ingredient.
    export kind uskLamp {
      toggle();
      setupUI(LampController controller);
    setTimeMachine (TimeMachine timeMachine, Vat vat);
    }

// Presences respond to notifications from other presences about changes
// in the lamps state, as well as the addition of new "switches".
    kind pskLamp {
      hostToggle();
      relayToggle(boolean newSwitchState);
    }

// Since there is only a single ingredient, we must declare it to handle
// both unum and presence messages.
    kind iskLamp {
      kind pskLamp;
      kind uskLamp;
    }

// This declaration explains how the presence is to be constructed
// and how unum and presence messages are to routed to ingredients.
    presence Structure psLamp {
        kind pskLamp;
        ingredient Lamp {
        kind iskLamp;
        deliver unum toggle;
        deliver unum setupUI;
        deliver unum setTimeMachine;
        deliver presence pskLamp;
      }
    }

// Most of the protocol is handled by the Lamp ingredient implementation
    ingredient Impl iiLamp {
      kind iskLamp;
      implements LampPeer;      // Handles UI
      implements Seismologist;  // Handles quake notification
      implements PresenceDelegate; // Handles Presence Death notification
      implements UnumKillHandler;  // Handles explicit Unum Kills
    // State shared among presences
      boolean switchState;   // State of the lamp

    // Local instance variables
      TimeMachine timeMachine;
      EResult timeMachineD;  
      LampController controller;
    LampOwner myOwner;
    
    function public boolean getSwitchState () { return switchState; }
  
  
  function public void noteUnumKilled ()  {
    EStdio.out().println("Lamp found out the Unum was killed, Unum: " + environment.unum);    
  }
  
    
      // Handle a request to toggle the state of the lamp (generated by a UI event).
      method hostToggle() {
        switchState = !switchState;
        RtEnvelope env = envelope((kind pskLamp) <- relayToggle(switchState));
        BasePresence.sendEnvelopeToOthers(environment.otherPresences, env);
        showLampStatus();
      }

      function void showLampStatus () {
        if (timeMachine != null) {      
          EStdio.out().println("Sending TimeMachine <- commit()");
          timeMachine <- commit(null);
        }
        controller.postEvent(LampController.EVENT_LAMP_STATE, switchState);
      }
  
      function void initialize(boolean theSwitchState) {
      switchState = theSwitchState;
        TimeMachine timeMachineChannel;
        timeMachine = timeMachineChannel;
        timeMachineD = &timeMachineChannel;
      }
  
      method setupUI(LampController controller) {
        boolean hostState = ((environment.flags & PresenceEnvironment.IsHostPresence) != 0);
        this.controller = controller;
        controller.setPeer(this, hostState, switchState);
        controller.postEvent(LampController.EVENT_LAMP_STATUS, switchState);
      }

      // Set the time machine
      method setTimeMachine(TimeMachine timeMachine, Vat vat) {
        timeMachineD <- forward(timeMachine);
        vat.waitForNext(this);
      }

      method unumDeathNotification() {
        EStdio.out().println("Lamp (PresenceDelegate): All other Presences are gone");
      }

      method noticeCommit () {
      }
    
      method noticeQuake (TimeQuake timeQuake) {
        showLampStatus();
        timeQuake.waitForNext(this);
      }
    
      method lampToggle() {
        toggle();
      }

    method lampInvalidate()  {
      Unum newLamp = invalidateAndMakeNewUnum();
    if (newLamp != null)  {
      myOwner <- noteNewLampUnum(newLamp);
    }
    }   
    
      method toggle() {
        if ((environment.flags & PresenceEnvironment.IsHostPresence) == 0) {
          environment.hostPresence <- (kind pskLamp).hostToggle();
        }
        else {
          hostToggle();
        }
      }

      // Handle a notification of a state change received from another presence.
      method relayToggle(boolean newSwitchState) {
        switchState = newSwitchState;
        showLampStatus();
      }

      // Constructor method to generate a prime presence of a lamp unum.
      method constructLamp(boolean switchState, LampOwner owner) {
        initialize(switchState);
      myOwner = owner;
      myOwner <- noteNewLampUnum(environment.unum);
      }
    
    method constructReplica(boolean switchState)  {
      initialize(switchState);
    }   
    }
    
    

    // Description of the Host Lamp's presence implementation:
    presence Impl piLampHost {
        Structure psLamp;  // Structure of the presence
    presenceBehavior IsHostPresence;
    
        // Initialization of prime presences
        prime init (boolean switchState, LampOwner owner) {
        setPresenceDelegate(Lamp);
          Lamp <- constructLamp(switchState, owner);
        }

        // and our one and only ingredient
        ingredient Lamp template {
          Impl iiLamp;
        }
  
       // How to make new presences
       make upnLampClient Lamp.getSwitchState();
    }
  
    // Description of the Client Lamp's presence implementation:
    presence Impl piLampClient {
        Structure psLamp;  // Structure of the presence
    presenceBehavior IsClientPresence, DieWhenNoOtherPresences;
    
        // Initialization of prime presences
        init (boolean switchState) {
        setPresenceDelegate(Lamp);
          Lamp <- constructReplica(switchState);
        }

        // and our one and only ingredient
        ingredient Lamp template {
          Impl iiLamp;
        }
    
       // How to make new presences
       make upnLampClient Lamp.getSwitchState();
    }

  export unum structure usLamp  {
    kind uskLamp;  
    presence upnLampHost kind pskLamp makes upnLampClient;
    presence upnLampClient kind pskLamp makes upnLampClient;
    prime upnLampHost;
  }
  
  unum impl uimLamp  {
    structure usLamp;
    presence upnLampHost impl piLampHost;
    presence upnLampClient impl piLampClient;
  } 
}
