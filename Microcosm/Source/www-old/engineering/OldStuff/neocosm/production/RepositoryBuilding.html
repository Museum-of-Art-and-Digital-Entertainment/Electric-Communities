<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252"><META NAME="Generator" CONTENT="Microsoft Word 97"><TITLE>Repository Building</TITLE></HEAD><BODY LINK="#0000ff" VLINK="#800080"><H1>Repository Building</H1><P><B>Last updated: </B>[98/07/08 <A HREF="mailto:wolfs@mci2000.com">Wolf</A>]<P>Author(s): <A HREF="mailto:wolfs@mci2000.com">Wolf</A>.<H2>Introduction</H2><BLOCKQUOTE>This document covers repository building from a high-level, integration perspective rather than a code or design perspective. It explains how to work with the current mysterious and complex repository creation process to perform day to day updates for Habitats or any other old Cosm application.</BLOCKQUOTE><H3>Related Documents</H3><A HREF="../Repository/index.html">Repository design documentation (Karl)</A><BR><A HREF="ProductionOverview.html">Production overview - how to use Production tools, etc (Tony)</A><BR><H2>A brief history</H2>Once upon a time, everyone in Production updated the SRC tree approximately daily, and then used the SRC and EC trees to generate a new local build. Eventually, two things happened more or less simultaneously that changed this behavior. First, with increased policing, the daily builds became much more reliable and were up-to-date enough in most cases for daily use. Second, something broke the builds on machines in Production. Tony pointed out that even a release build actually contained the classes necessary both to access the repository and to create a new repository or finesse an existing one. See <A HREF="../Repository/index.html">Karl's design documentation</A> for why that was probably a bad idea. In any case, all that was necessary to curate from a release build was a simple batch script and some properly initialized environment variables, as will be explained next.<H2>Procedures and elements</H2>From the production standpoint, there are two types of files that need to be edited for each specific repository build: the BAT file and the CUR file. The BAT file sets environment variables (typically but not necessarily the same from one build to the next) and then calls the repository class with a series of arguments. One of these arguments is which CUR file to load. The CUR file in turn uses the metalanguage understood by the curation process for opening repositories, adding or checking files, certifying, and other operations.<H3>Environment variables</H3>We found that it was best to start with a clean slate for environment variables, and reset the variables upon each run of a command-line environment. For ease of use, you should still use 4DOS, but launch it with a separate BAT file as an argument. The initial BAT file clears any possible PATH= or CLASSPATH=  sets from AUTOEXEC files or other locations.<P>For example: the batch for the actual shell-level 4DOS intialization might read simply:<PRE>SET PATH=SET CLASSPATH=</PRE>Using this essentially clean shell, load specific BAT files that are tailored for each repository build operation. Each BAT file first resets the environment variables such that the execution can first find a Java runtime and then find the specific curator classes. For this initial section, a typical BAT file might read:<PRE>set PATH=C:\cosm\lib;C:\cosm\java\bin;C:\WINDOWS;C:\WINDOWS\COMMANDset CLASSPATH=C:\cosm\classes\startup.zip;C:\cosm\classes\ucosm.zip;C:\cosm\java\lib\classes.zip</PRE>\COSM\JAVA\LIB will find classes.zip, and \COSM\LIB will find the matching versions of support DLL's for rendering required during curation. Note that this is a good way to avoid using 'polluted' versions of the runtime DLL's, unless you've installed any DLL's into \WINDOWS\SYSTEM (those DLL's would always be called first regardless of runtime sets). Delete any Cosm-specific DLL's you find in your system root!<P>The CLASSPATH section mirrors the runtime order specified when the client runs, to assure that everything that happens at curation will be extracted using the same or related classes that will be used at runtime.<P>This batch file should be run at the /MEDIA level, because the /IMAGES subpath is assumed by the internal lookup mechanism for VRML files called from within Appearance files.<BLOCKQUOTE><H3>Calling the repository class</H3></BLOCKQUOTE>The next part of the batch file calls the actual repository class as an argument to running the Java VM, using the ec.e.boot class as an intermediary for launching e. Once this class is opened, it expects several named arguments to be filled, usually including REP, IN and ECHOME at a minimum. REP is the name of the repository to be output; this will actually default to a repository named Repository if not filled in. IN is the CUR file that contains further instructions for the curation process; if this isn't provided, the curator defaults to running in command-line mode. ECHOME is required so that the repository class can find an existing repository to open. I believe the reasons for this are that the class must essentially bootstrap itself and needs to have a repository open before another can be created, though I'm not sure why. What's important is that if you don't have a file named Repository in your ECHOME location, nothing works.<P>An example repository classfile call might look like:<PRE>%BINDIR%java ec.e.boot.EBoot ec.cosm.tools.curator rep=accessoriesRepository in=accessories.cur verb=3 ECHome=\Cosm\ECHome &gt;accessories.out</PRE>The &gt; redirects the output that would otherwise be sent to the console to a file. Capturing the file is often essential for debugging purposes, especially if the verbosity for logging is set high.<H3>The CUR file</H3>A CUR file consists entirely of commands that are understood only by the repository classes at runtime. For the most part, a typical CUR file will contain the names of files to be added to a repository plus a few other special commands such as ERASE (clears the repository and prevents appending).<P>Appearance2d files are added to a repository using the CRAPP2D command. Appearance3d files are added to a repository using the CRAPP3D command. Nearly all other media files (bitmaps, sounds, GIF's etc.) are added to a repository using the CRADD command. Each of these commands takes essentially two commands. The first command gives the local file reference to be added. The second specifies the string token to be assigned for that repository item, such that the item can be called from a catalog file or realmtext. The token labels are not inherently case sensitive, but because of some problems with the VRML parser any bitmap called by VRML must be cased the same in its label as in the referring Appearance3D file. As a result, it's a good practice to case the bitmaps properly to aid in debugging later.<P>CUR files can be put together by hand in a text editor, but this is not practical for large directories or large scale repository builds. The Production tool curateScript.EXE is a self executing Perl script for generating a CUR file listing of all files in a directory, giving appropriate CRADD or CRAPP commands for each file, assigning a label of the default last-directory-plus-filename format. Just place the curateScript.EXE program in the directory where the files to curate reside, and double-click in Explorer or run from command line. The current version of the tool does not recurse directories, so it will still be necessary to paste together multiple CUR files for a large multifolder repository.<P>Here's a short example CUR file for a noncertified build:<PRE>erase cradd "C:/media/images/greekturf/ThumbGreek.gif" "greekturf/ThumbGreek.gif"cradd "C:/media/images/greekturf/plants.BMP" "greekturf/plants.BMP"cradd "C:/media/images/greekturf/background.bmp" "greekturf/background.bmp"cradd "C:/media/images/greekturf/floor.bmp" "greekturf/floor.bmp"cradd "C:/media/images/greekturf/portal.bmp" "greekturf/portal.bmp"cradd "C:/media/images/greekturf/arches.bmp" "greekturf/arches.bmp"crapp2D "C:/media/images/greekturf/plants.Appearance2D" "greekturf/plants.Appearance2D"crapp2D "C:/media/images/greekturf/floor.Appearance2D" "greekturf/floor.Appearance2D"crapp2D "C:/media/images/greekturf/arches.Appearance2D" "greekturf/arches.Appearance2D"crapp2D "C:/media/images/greekturf/background.Appearance2D" "greekturf/background.Appearance2D"crapp2D "C:/media/images/greekturf/portal.Appearance2D" "greekturf/portal.Appearance2D"</PRE>Although the CRADD's and CRAPP's can be alternated throughout a CUR file, it is necessary to curate the called elements before the Appearance files, or the elements won't be found and curation will either hang or generate an error. Note the <B>forward slashes</B> on all the "paths" for file references - if you're using direct DOS output you'll have to search and replace to use forward slashes here instead of DOS's backslashes.<H3>Curation with swatching</H3>Because of bugs in the texture calling process, any element called as a swatchable must be called inside the same CUR file even if it already exists in the master repository or some other adjunct repository; in other words each swatchable element must be present at curation time and where these elements might be at runtime is irrelevant. As a result, you might need to duplicate elements within an adjunct repository build to get curation to run. Otherwise, the entire curation process hangs. This is necessary only if textures will be used to fill as defaults for swatchables, not if textures are used directly.<H3>Verbosity</H3>Verbosity 2 suppresses nearly all output except the hashkey size of the initially opened repository. Verbosity 3 adds the size of the newly created repository to the output, useful when comparing the numbers of entries in the CUR file to the eventual output, as well as calling out each opening and closing step. Verbosity 4 outputs a line for each file added, reiterating the input file source and displaying both the string token and the hashkey that the file was assigned. Verbosity outputs the opening and closing steps in addition to the per-file information supplied by verbosity 4. Any other value besides 2 thru 5 defaults to verbosity 3.<H3>Output debugging</H3>Output can tell you whether a file cannot be found at the given local file location, which is usually simple to correct. Output also displays any parsing failures, both in Appearance files and VRML files. Some parsing errors aren't displayed with much helpful information, whereas others will give the last text token and what token was expected, as well as perhaps a line number. VRML errors are usually not line specific and simply tell you that the file couldn't be parsed. Note that this can also mean that the VRML file was not found (a common error if not running the batch file from the /MEDIA root). When in doubt, remember that both the Appearance file parser and the VRML parser are linear parsers, not pure token parsers, so often the actual error is in the line / section preceding the called-out error.<P>For full details on Appearance file syntax, see the <A HREF="ProductionOverview.html">Production Overview document</A>. Some examples of errors that will not be caught by output errors: doubling up on a token name, calling a nonexistent menu label (gives a runtime crash), trying to call a bitmap in an unsupported format (various runtime errors &  crashes) or bad structure in VRML when called by animations. Tony is our resident expert on debugging what might be wrong with an Appearance file.<H2>Curation with certification</H2>Curation with certification introduces more complexity. The batch file must establish a connection to a CertAngency server, which then returns the certificates used by any requested certification pass. In essence, certification is a separate step performed on elements that already exist in the repository, but we've typically included certification in the same process as the first introduction of the media to the repository. Certificates add a lot of time to the curation process, so it's best to run certification only when you're sure that all the media is debugged.<H3>Calling the repository class for certification</H3>In addition to the REP, IN and ECHOME arguments, several other arguments must be added to the BAT file to establish a connection to the CertAgency and describe what to do once the connection is open. SEARCHPATH looks for active CertAgency processes. CERTAGENCYREF loads a local SturdyRef that is sent to the CertAgency to establish that you are allowed to receive a certificate (this SturdyRef file should exist locally and if not can be found in the CVS tree at the \MEDIA level). CERTIFICATES names the local repository that contains only certificates <FONT COLOR="#FF0000">(NOTE: I'm not sure whether this is required or what it's for; this cert repository doesn't ship. Someone in the know, please clarify here...)</FONT>. This is a <B>required</B> argument.An example repository classfile call might look like:<PRE>%BINDIR%java ec.e.boot.EBoot ec.cosm.tools.curator in=adj4.cur rep=SeniorsRepository CertAgencyRef=CertAgencySRef SearchPath=harpo.communities.com:1670;george.communities.com:1670 ECHome=\cosm\ECHome certificates=CertRepository ECHome=\Cosm\ECHome</PRE>If no CertAgency could be found, curation will continue but any certification step will fail due to lack of a certificate. Details on restarting a downed CertAgency can be found in <A HREF="../cert/CertAgencySubsystem.html">Mike's document on certification</A>.<H3>Certification steps in the CUR file</H3>In the 'master' repository build process, certificates were added to items in a secondary step, as part of the long and arcane BOM to ucosm.cur conversion. Certificates are added by performing searches on labels and certifying the search result list, or by certifying individual items. The following is an example section of how the certificates were added to repositories shipped as add-ons for the Alpha test:<PRE>searchlabels appearancecertifyLastSearch "ECCert-V0.9" "06/09/1998"certifyLastSearch "KidSafe-V0.9" "06/09/1998"searchlabels bmpcertifyLastSearch "ECCert-V0.9" "06/09/1998"certifyLastSearch "KidSafe-V0.9" "06/09/1998"</PRE>SEARCHLABELS generates a list of handles by label, CERTIFYLASTSEARCH applies the certificates specified to each file in that list. Bitmaps used for swatching must be certified independently of Appearance files, otherwise individual bitmaps called directly by certified Appearance files need not be certified. In this case ALL bitmaps were certified, which may or may not have a performance detrement. SEARCHLABELS generates the list of element that you'll be able to see in the OUT file if verbosity is set to 3 or above. Then, the results of the search are given certification (in this case 2 certificates). While elements are being certified you'll see dot-ticks in STDOUT until the process is complete.<H2>Miscellaneous</H2><H3>Special case: menus.uifile</H3>Including menus.uifile in a repository uses a different curation command:<PRE>cruifile "C:/media/images/menus.uifile" "menus.uifile"</PRE>You must curate with this label. Note that this CUR command is not documented in the 'help' for the command line curator.<H3>The curator from the command line</H3>You can 'poke' at the curator directly through a command line. You only need to open an existing repository and give a valid ECHOME. The following is an example BAT file that would open the curator and leave it open in command line state:<PRE>rem opens to command line presumes your install is in \cosm\ECHomeset PATH=C:\cosm\lib;C:\cosm\java\bin;C:\WINDOWS;C:\WINDOWS\COMMANDset CLASSPATH=C:\cosm\classes\startup.zip;C:\cosm\classes\ucosm.zip;C:\cosm\java\lib\classes.zip%BINDIR%java ec.e.boot.EBoot ec.cosm.tools.curator ECHome=\cosm\ECHome</PRE>If you type 'help' at this command line you'll get the following useful text:<PRE>?Command, one of the following:help                               Prints this crufterase                              Erase current Repositoryadd &lt;path&gt; &lt;key&gt;                   Add item to Repositorycradd &lt;path&gt; &lt;label&gt; &lt;keywordlist&gt; Add using Cryptohash key. Also add label  to %SymbolTable%listCertKeyRing                        List all the certification keys in the key ringcertifyall &lt;certname&gt; &lt;Exp. Date&gt;  Certify every item so far w/ the specified cert and expiration date                 &lt;"d/M/yyyy"&gt;certifyLastAdd &lt;certname&gt; &lt;Exp. Date&gt;  Certify last added item w/ the specified cert and expiration date              &lt;"d/M/yyyy"&gt;certifyLastSearch &lt;certname&gt; &lt;Exp. Date&gt;      Certify items from the last searchLabels command&lt;"d/M/yyyy"&gt;decertifyLastSearch &lt;certname&gt;     remove certificate from items from the last searchLabels commanddelabel                            Remove the %SymbolTable% and the %KeywordsTable% to save diskspacestat                               Show summary informationls                                 List keys Repositoryll                                 List labels in Repositorys %SymbolTable%cd                                 Sets a filtering prefix for the ll command, similar to UNIX cd commandpwd                                Prints current filtering prefixkeywords &lt;symbol&gt; &lt;keywordlist&gt;    Add keywords to item in RepositorysearchLabels &lt;string&gt;              Search %Symboltable% for stringfind &lt;keywordlist&gt;                 Show records that have any keyword that matches any keyword in listanalyze                            Analyze all Repository's filesrepair                             Attempt to check and repair all Repository's filesverb &lt;int&gt;                         Set verbosity level. 0=quiet, 5=all. Starts as 3exit                               Exits</PRE>Of these, you'll recognize several commands from the CUR files. Here's what I know about the others:<UL TYPE="CIRCLE"><LI>ListcertKeyRing crashes.<LI>The certification commands work only if your batch file has already established a connection to the CertAgency and pulled down a certificate.<LI>Find is unimplemented.<LI>CD appears to work fine until you try to go back UP a branch to the root (it can't understand either CD .. or CD \). Use PWD to find out where you are.<LI>LS does <B>not</B> filter on your 'directory' location.<LI>Repair does seem to run and take a long time, which is scary, then tells you it's 'repaired' X keys. Sounds suspiciously like ScanDisk...<LI>Analyse does absolutely nothing.<LI>Tring to change VERB while running gives strange results.</UL><H3>Other examples</H3>Some more examples can be found in \\ALEXANDRIA\ART\PRODUCTION\CURATIONEXAMPLES. This will include some of the longer CUR files and some BAT files. Several of the CUR files for curating the incremental repositories are checked into CVS at the \MEDIA level.<H3>Building repositories and other files into self extracing archives</H3>All files to include in a self extracting WinZip extractor first need to be included in a WinZip file. Create the WinZip file using wildcards and recursing directories, such that you are mirroring the directory structure under a user's default install, for instance every directory under C:\Program Files\EC Habitats. Then set the root install directory to be C:\Program Files\EC Habitats when you build the self extracting archive, and you'll be able to exactly update and mirror a remote client install. See Randy for licensing information on WinZip SE.<H3>The media tree MAKE process</H3>MAKE from the media tree goes through the following chain of events.<OL><LI>Make is interpreted as a reserved word and in the case of being executed in the /MEDIA directory calls the ALL: section of GNUMAKEFILE.<LI>CREATE.BOM is called. This script generates a list of all files of type (<TT>bmp gif html ico jpg ppm wav</TT>), then a separate list of files containing the string 'demi' and all bitmaps found in the Functional.Swatches.txt catalog. The second set of files is used as a list for special certification operations. The list is manipulated into the BOM textfile. BOM uses an entirely different syntax than a regular CUR file, though it greatly resembles the first half of a CUR file, with file locations but without labels. Items in the specified swatch catalog get the CERT prefix, all other bitmaps get the UNCERT prefix.<LI>Next in sequence in GNUMAKEFILE, the CREATE.CURATOR.FILE script is called. This script generates a valid CUR file from the BOM by replacing the special BOM only syntax with CUR syntax and generating labels by searching for forward slashes. <B>Note that labels are constructed by duplicating everything past the /IMAGES level.</B> This has become the standard, and is why labels for areas such as avatars, interface elements and color chips contain 2 or sometimes 3 nested directories.<LI>Next in sequence in GNUMAKEFILE, the CREATE.REPOSITORY script is called. Curator class is called with UCOSM.CUR as curfile argument. Note that the curator classes in this case are connecting to a CertAgency; the parameters for this connect are hidden in file CURATOR.PROPS. Everything in the CUR file is added to a default named Repository. Swatch bitmaps are added first, everything added up to that point is certified with specified certificates, then the remainder of bitmaps, other files and Appearance files are added. Labels are searched for string "Appearance" and resulting search list is certified with the specified certificates.</OL>If this sequence was to be rehabilitated for use in a full repository build again, the method by which non-Appearance files were certified would have to be improved to search through additional swatching catalogs.</BODY></HTML>