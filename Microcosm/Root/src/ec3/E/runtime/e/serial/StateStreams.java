/**
 * StateStreams.java
 *
 * Copyright 1997 Electric Communities. All rights reserved worldwide.
 * Arturo Bejar
 * December 7 1997
 *
 */

package ec.e.serial;

import java.io.Serializable;
import java.io.OutputStream;
import java.io.InputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;

import ec.e.run.RtDeflector;
import ec.e.start.EEnvironment;
import ec.e.net.Registrar;
import ec.e.net.SturdyRef;
import ec.e.run.RtDelegatingSerializable;

import ec.e.file.EStdio;


/**
 * Implements the basic state oriented encoding, provides a specific
 * writeObject method for all EObjects. This class is final to allow
 * the classes that are being encoded to check that they are being
 * encoded by a trusted class. 
 * @see java.io.ObjectOutputStream
 * 
 */

public final class StateOutputStream
        extends java.io.ObjectOutputStream {

    /** Variables for decoding/validating priorities */

    /** Used for SoulState unum instation */
    static public final int UNUM_VALIDATE = 10;
    /** Used for facet instantiation that happens after unums */
    static public final int FACET_VALIDATE = 5;

 
    StateObjectWriteInterest myInterest = null;
    
    public StateOutputStream(OutputStream out) throws IOException {
        super(out);
        this.enableReplaceObject(false);
    }
    
    public StateOutputStream(OutputStream out, StateObjectWriteInterest interest) throws IOException {
      this(out);
        setMyInterest(interest);
    }

    protected void setMyInterest(StateObjectWriteInterest interest)  {
      myInterest = interest;
    }
    
    /**
     * Enforces the following encoding policy for EObjects: <p>
     * - Proxies get encoded as null. <p>
     * - RtDelegatingSerializable encode their targets. <p>
     * - Tries to encode otherwise, if the class is not encodable it throws.
     * @param object to write.
     * @throws IOException
     * 
     */
    
    protected Object replaceObject(Object obj) throws IOException {
//      System.out.println();
//      System.out.println("[StateOutputStream]Calling replaceObject: " + obj);

        Object repObject = null;
        
        if (obj instanceof RtDelegatingSerializable) {
            System.out.println(" RtDelegatingSerializable: ");
            repObject = ((RtDelegatingSerializable)obj).delegateToSerialize();
        } else if (obj instanceof EProxy) {
            System.out.println(" EProxy: null");
            // Proxies are encoded as null.
            repObject = null;
        } else {
            System.out.println("  Just trying to encode...");
            // Otherwise just continue encoding.
            repObject = (Serializable)obj;
        }
        
        // Notify interest (if any) we are writing given object to stream
   if (myInterest != null) myInterest.objectToBeWritten(this, obj);
        
        return repObject;
 }

    public void policyWriteObject(Object obj) throws IOException {
        if (obj instanceof RtDelegatingSerializable) {
            // Get its delegate and write it out
            policyWriteObject(((RtDelegatingSerializable)obj).delegateToSerialize());
        } else if (obj instanceof EProxy) {
            // Proxies are encoded as null.
            super.writeObject(null);
        } else {
            // Otherwise just continue encoding.
            super.writeObject(obj);;        
        }
    }
}

/**
 * Used for reading in a stream generated by a StateOutput stream, this
 * class is also reponsible for delivering the enviroment to certain
 * classes of objects as they are decoded.
 * 
 */

public final class StateInputStream
    extends java.io.ObjectInputStream {

    private EEnvironment myEEnvironment;
    private StateObjectReadInterest myInterest=null;

    public StateInputStream(EEnvironment env, InputStream in) throws IOException {
        super(in);      
        myEEnvironment = env;
        // We use resolve object to handle existing, valid registrars.
        this.enableResolveObject(true);
    }
    
    public StateInputStream(EEnvironment env, InputStream in, StateObjectReadInterest interest) throws IOException {
      this(env, in);
        setMyInterest(interest);
    }
    
    protected void setMyInterest(StateObjectReadInterest interest)  {
      myInterest = interest;
    }
    
    protected Object resolveObject(Object obj) throws IOException {
        Object repObject=obj;
            
            if (obj instanceof Registrar) {
                System.out.println("[StateInputStream]:resolveObject:Registrar");
                Object registrar = Registrar.summon(myEEnvironment);
                System.out.println("                   Registrar summond equals decoded:"+(registrar == obj));
                repObject = registrar;
            }
            
            if (myInterest != null) myInterest.objectToBeRead(this, obj);
            return repObject;
            
    }
    /**
     * Returns environment if you are one of the designated classes that 
     * can get it, note that when you add a class to this list make sure that
     * it is final so that someone can't just extend it, make one, and get the
     * environment.
     * @returns EEnvironment if a valid class asks, null otherwise.
     */

    public EEnvironment getEEnvironment(Object obj) {
        
        if (null == obj) return null;
        
        if (obj instanceof ec.e.net.Registrar) {
            return myEEnvironment;          
        } else if (obj instanceof ec.e.net.SturdyRef) {
            return myEEnvironment;
        }
        return null;
    }       
}

