# 1 "ec/ecomp/constfold.java" 
/* ************************************************************************
 * Espresso! Constant folding
 * Copyright 1995 Martin Odersky. All rights reserved.
 * 
 * Author     : Martin Odersky
 * Last change: 13-Mar-96
 *************************************************************************/


package ec.ecomp;
# 13 "ec/ecomp/constfold.java" 


class ConstantFolder implements /*imports*/ Constants {

/** convert boolean to integer (true = 1, false = 0).
 */
    static int b2i(boolean b) {
        return b ? 1 : 0;
    }

/** fold binary operation.
 */
    static Item fold(int pos, 
                     ImmediateItem left, ImmediateItem right, 
                     int opcode) {
        try {
            if (opcode >= (1 << preShift)) {
                Item i = fold(pos, left, right, opcode >> preShift);
                if (i instanceof ImmediateItem)
                    return fold(pos, (ImmediateItem)i, opcode & preMask);
                else
                    return i;
            } else if (opcode == if_acmpeq) {
                return 
                    new ImmediateItem(
                        Integer.valueOf(left.value == right.value ? 1 : 0));
            } else if (opcode == if_acmpne) {
                return 
                    new ImmediateItem(
                        Integer.valueOf(left.value != right.value ? 1 : 0));
            } else {
                Number l = (Number)left.value;
                Number r = (Number)right.value;
                Number res;
                switch (opcode) {
                case iadd:
                    res = Integer.valueOf(l.intValue() + r.intValue()); break;
                case isub:
                    res = Integer.valueOf(l.intValue() - r.intValue()); break;
                case imul:
                    res = Integer.valueOf(l.intValue() * r.intValue()); break;
                case idiv:
                    res = Integer.valueOf(l.intValue() / r.intValue()); break;
                case imod:
                    res = Integer.valueOf(l.intValue() % r.intValue()); break;
                case iand:
                case bool_and:
                    res = Integer.valueOf(l.intValue() & r.intValue()); break;
                case ior:
                case bool_or:
                    res = Integer.valueOf(l.intValue() | r.intValue()); break;
                case ixor:
                    res = Integer.valueOf(l.intValue() ^ r.intValue()); break;
                case ishl:
                    res = Integer.valueOf(l.intValue() << r.intValue()); break;
                case ishr:
                    res = Integer.valueOf(l.intValue() >> r.intValue()); break;
                case iushr:
                    res = Integer.valueOf(l.intValue() >>> r.intValue()); break;
                case if_icmpeq:
                    res = Integer.valueOf(b2i(l.intValue() == r.intValue())); break;
                case if_icmpne:
                    res = Integer.valueOf(b2i(l.intValue() != r.intValue())); break;
                case if_icmplt:
                    res = Integer.valueOf(b2i(l.intValue() < r.intValue())); break;
                case if_icmpgt:
                    res = Integer.valueOf(b2i(l.intValue() > r.intValue())); break;
                case if_icmple:
                    res = Integer.valueOf(b2i(l.intValue() <= r.intValue())); break;
                case if_icmpge:
                    res = Integer.valueOf(b2i(l.intValue() >= r.intValue())); break;

                case ladd:
                    res = Long.valueOf(l.longValue() + r.longValue()); break;
                case lsub:
                    res = Long.valueOf(l.longValue() - r.longValue()); break;
                case lmul:
                    res = Long.valueOf(l.longValue() * r.longValue()); break;
                case ldiv:
                    res = Long.valueOf(l.longValue() / r.longValue()); break;
                case lmod:
                    res = Long.valueOf(l.longValue() % r.longValue()); break;
                case land:
                    res = Long.valueOf(l.longValue() & r.longValue()); break;
                case lor:
                    res = Long.valueOf(l.longValue() | r.longValue()); break;
                case lxor:
                    res = Long.valueOf(l.longValue() ^ r.longValue()); break;
                case lshl:
                    res = Long.valueOf(l.longValue() << r.intValue()); break;
                case lshr:
                    res = Long.valueOf(l.longValue() >> r.intValue()); break;
                case lushr:
                    res = Long.valueOf(l.longValue() >>> r.intValue()); break;
                case lcmp:
                    if (l.longValue() < r.longValue()) 
                        res = Integer.valueOf(-1);
                    else if (l.longValue() > r.longValue()) 
                        res = Integer.valueOf(1);
                    else
                        res = Integer.valueOf(0);
                    break;

                case fadd:
                    res = Float .valueOf(l.floatValue() + r.floatValue()); break;
                case fsub:
                    res = Float .valueOf(l.floatValue() - r.floatValue()); break;
                case fmul:
                    res = Float .valueOf(l.floatValue() * r.floatValue()); break;
                case fdiv:
                    res = Float .valueOf(l.floatValue() / r.floatValue()); break;
                case fmod:
                    res = Float .valueOf(l.floatValue() % r.floatValue()); break;
                case fcmpg: case fcmpl:
                    if (l.floatValue() < r.floatValue()) 
                        res = Integer.valueOf(-1);
                    else if (l.floatValue() > r.floatValue()) 
                        res = Integer.valueOf(1);
                    else if (l.floatValue() == r.floatValue())
                        res = Integer.valueOf(0);
                    else if (opcode == fcmpg)
                        res = Integer.valueOf(1);
                    else
                        res = Integer.valueOf(-1);
                    break;

                case dadd:
                    res = Double.valueOf(l.doubleValue() + r.doubleValue()); break;
                case dsub:
                    res = Double.valueOf(l.doubleValue() - r.doubleValue()); break;
                case dmul:
                    res = Double.valueOf(l.doubleValue() * r.doubleValue()); break;
                case ddiv:
                    res = Double.valueOf(l.doubleValue() / r.doubleValue()); break;
                case dmod:
                    res = Double.valueOf(l.doubleValue() % r.doubleValue()); break;
                case dcmpg: case dcmpl:
                    if (l.doubleValue() < r.doubleValue()) 
                        res = Integer.valueOf(-1);
                    else if (l.doubleValue() > r.doubleValue()) 
                        res = Integer.valueOf(1);
                    else if (l.doubleValue() == r.doubleValue())
                        res = Integer.valueOf(0);
                    else if (opcode == dcmpg)
                        res = Integer.valueOf(1);
                    else
                        res = Integer.valueOf(-1);
                    break;
                default:
                    throw new CompilerError("fold " + opcode);
                }
                return new ImmediateItem(res);
            }
        } catch (ArithmeticException e) {
            Report.error(pos, e.toString());
            return Item.stackItem;
        }
    }

/** fold unary operation.
 */        
    static Item fold(int pos, ImmediateItem od, int opcode) {
        try {
            Number x = (Number)od.value;
            Number res;
            switch (opcode) {
            case nop:
                res = x; break;
            case ineg:
                res = Integer.valueOf(-x.intValue()); break;
            case ixor:
                res = Integer.valueOf(~x.intValue()); break;
            case bool_not:
                res = Integer.valueOf(~x.intValue() & 1); break;
            case ifeq:
                res = Integer.valueOf(b2i(x.intValue() == 0)); break;
            case ifne:
                res = Integer.valueOf(b2i(x.intValue() != 0)); break;
            case iflt:
                res = Integer.valueOf(b2i(x.intValue() < 0)); break;
            case ifgt:
                res = Integer.valueOf(b2i(x.intValue() > 0)); break;
            case ifle:
                res = Integer.valueOf(b2i(x.intValue() <= 0)); break;
            case ifge:
                res = Integer.valueOf(b2i(x.intValue() >= 0)); break;

            case lneg:
                res = Long.valueOf(-x.longValue()); break;
            case lxor:
                res = Long.valueOf(~x.longValue()); break;

            case fneg:
                res = Float .valueOf(-x.floatValue()); break;

            case dneg:
                res = Double.valueOf(-x.doubleValue()); break;

            default:
                throw new CompilerError("fold " + opcode);
            }
            return new ImmediateItem(res);
        } catch (ArithmeticException e) {
            Report.error(pos, e.toString());
            return Item.stackItem;
        }
    }
}








