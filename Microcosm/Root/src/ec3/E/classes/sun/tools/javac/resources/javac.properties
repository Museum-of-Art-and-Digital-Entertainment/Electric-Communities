#
# Copyright (c) 1994-1997 by Sun Microsystems Inc.
#
# @(#)javac.properties	1.15 97/03/10
#

javac.err.internal=\
	Internal error.
javac.err.eof.in.comment=\
	Comment not terminated at end of input.
javac.err.eof.in.string=\
	String not terminated at end of input.
javac.err.newline.in.string=\
	String not terminated at end of line.
javac.err.invalid.char.constant=\
	Invalid character constant.
javac.err.unbalanced.paren=\
	Unbalanced parentheses.
javac.err.invalid.escape.char=\
	Invalid escape character.
javac.err.invalid.octal.number=\
	Invalid character in octal number.
javac.err.invalid.number=\
	Invalid character in number.
javac.err.funny.char=\
	Invalid character in input.
javac.err.float.format=\
	Invalid floating point format.
javac.err.overflow=\
	Numeric overflow.
javac.err.underflow=\
	Numeric underflow.
javac.err.token.expected=\
	''{0}'' expected.
javac.err.statement.expected=\
	Statement expected.
javac.err.type.expected=\
	Type expected.
javac.err.identifier.expected=\
	Identifier expected.
javac.err.class.expected=\
	''class'' or ''interface'' keyword expected.
javac.err.toplevel.expected=\
	Class or interface declaration expected.
javac.err.missing.term=\
	Missing term.
javac.err.else.without.if=\
	''else'' without ''if''.
javac.err.catch.without.try=\
	''catch'' without ''try''.
javac.err.finally.without.try=\
	''finally'' without ''try''.
javac.err.try.without.catch.finally=\
	''try'' without ''catch'' or ''finally''.
javac.err.case.without.switch=\
	''case'' outside switch statement.
javac.err.default.without.switch=\
	''default'' outside switch statement.
javac.err.io.exception=\
	I/O error in {0}.
javac.err.array.index.required=\
	Array index required.
javac.err.not.array=\
	[] can only be applied to arrays. It can''t be applied to {0}.
javac.err.array.dim.in.decl=\
	Can''t specify array dimension in a declaration.
javac.err.array.dim.in.type=\
	Can''t specify array dimension in a type expression.
javac.err.invalid.array.expr=\
	Array constants can only be used in initializers.
javac.err.invalid.array.init=\
	Invalid initializer for type {0}.
javac.err.invalid.lhs.assignment=\
	Invalid left hand side of assignment.
javac.err.invalid.args=\
	Invalid arguments to {0}.
javac.err.invalid.cast=\
	Invalid cast from {0} to {1}.
javac.err.invalid.instanceof=\
	Impossible for {0} to be instance of {1}.
javac.err.invalid.type.expr=\
	Invalid type expression.
javac.err.anonymous.extends=\
	Only named classes can have ''extends'' or ''implements'' clauses.
javac.err.invalid.field.reference=\
	Attempt to reference field {0} in a {1}.
javac.err.no.such.field=\
	No variable {0} defined in {1}.
javac.err.no.field.access=\
	Variable {0} in {1} not accessible from {2}.
javac.err.no.type.access=\
	Inner type {0} in {1} not accessible from {2}.
javac.err.no.static.field.access=\
	Can''t make a static reference to nonstatic variable {0} in {1}.
javac.err.inner.static.ref=\
	Can''t make a static reference to inner class {0}.
javac.err.ambig.field=\
	Reference to {0} is ambiguous. It is defined in {1} and {2}.
javac.err.invalid.field=\
	Attempt to reference method {0} in {1} as an instance variable.
javac.err.assign.to.final=\
	Can''t assign a value to a final variable: {0}
javac.err.assign.to.blank.final=\
	Can''t assign a second value to a blank final variable: {0}
javac.err.assign.to.blank.final.in.loop=\
	Attempt to assign a blank final {0} variable in a loop. The initialization must occur exactly once.
javac.err.assign.to.uplevel=\
	Attempt to assign to a variable {0} in a different method. From enclosing blocks, only final local variables are available.
javac.err.invalid.uplevel=\
	Attempt to use a non-final variable {0} from a different method. From enclosing blocks, only final local variables are available.
javac.err.uplevel.private=\
	Access across scopes to the private member {0} in {1} is not implemented.  The reference will succeed if the member is given package scope.
javac.err.undef.var=\
	Undefined variable: {0}
javac.err.undef.var.super=\
	Undefined variable: {0}.  The "super" keyword may only be used for member access and constructor invocation.
javac.err.undef.var.or.package=\
	Undefined variable or package name: {0}
javac.err.undef.var.class.or.package=\
	Undefined variable, class, or package name: {0}
javac.err.undef.var.or.class=\
	Undefined variable or class name: {0}
javac.err.var.not.initialized=\
	Variable {0} may not have been initialized.
javac.err.final.var.not.initialized=\
	Blank final variable ''{0}'' may not have been initialized. It must be assigned a value in an initializer, or in every constructor.
javac.err.access.inst.before.super=\
	Can''t reference {0} before the superclass constructor has been called.
javac.err.ambig.class=\
	Ambiguous class: {0} and {1}
javac.err.invalid.arg=\
	Invalid argument to {0}.
javac.err.invalid.arg.type=\
	Invalid argument type {0} for {1}.
javac.err.invalid.length=\
	''length'' applied to {0}, which is not an array.
javac.err.invalid.constr.invoke=\
	Only constructors can invoke constructors.
javac.err.constr.invoke.not.first=\
	Constructor invocation must be the first thing in a method.
javac.err.invalid.method.invoke=\
	Can''t invoke a method on a {0}.
javac.err.undef.meth=\
	Method {0} not found in {1}.
javac.err.no.meth.access=\
	Method {0} in {1} is not accessible from {2}.
#warning:
javac.err.no.override.access=\
	Note: Method {0} in {1} does not override the corresponding method in {2}, which is private to a different package.
javac.err.no.static.meth.access=\
	Can''t make static reference to method {0} in {1}.
javac.err.invalid.protected.method.use=\
	Can''t access protected method {0} in {1}. {2} is not a subclass of the current class.
javac.err.invalid.protected.field.use=\
	Can''t access protected field {0} in {1}. {2} is not a subclass of the current class.
javac.err.invalid.protected.type.use=\
	Can''t access protected inner type {0} in {1}. {2} is not a subclass of the current class.
javac.err.invalid.method=\
	Reference to variable {0} in {1} as if it were a method.
javac.err.invalid.var=\
	Reference to method {0} in {1} as if it were a variable.
#all deprecation-related messages are warnings:
javac.err.class.is.deprecated=\
	Note: {0} has been deprecated.
javac.err.meth.is.deprecated=\
	Note: The method {0} in {1} has been deprecated.
javac.err.override.is.deprecated=\
	Note: The method {0} in {1} has been deprecated, and {2} (which is not deprecated) overrides it.
javac.err.constr.is.deprecated=\
	Note: The constructor {0} has been deprecated.
javac.err.field.is.deprecated=\
	Note: The variable {0} in {1} has been deprecated.
javac.err.note.deprecations=\
	Note: {0} files use deprecated APIs.  Please consult the documentation for a better alternative in each case.
javac.err.note.1deprecation=\
	Note: {0} uses a deprecated API.  Please consult the documentation for a better alternative.
javac.err.note.deprecations.silent=\
	Note: {0} files use deprecated APIs.  Recompile with "-deprecation" for details.
javac.err.note.1deprecation.silent=\
	Note: {0} uses a deprecated API.  Recompile with "-deprecation" for details.
javac.err.invalid.array.dim=\
	Invalid array dimension.
javac.err.ambig.constr=\
	Constructor is ambiguous: {0}, {1}
javac.err.explicit.cast.needed=\
	Incompatible type for {0}. Explicit cast needed to convert {1} to {2}.
javac.err.incompatible.type=\
	Incompatible type for {0}. Can''t convert {1} to {2}.
javac.err.invalid.term=\
	Invalid term.
javac.err.private.intf.method=\
	{0} must override {1} with a public method in order to implement {2}.
javac.err.abstract.class=\
	{0} must be declared abstract. It does not define {1} from {2}.
javac.err.abstract.class.not.final=\
	{0} must be declared abstract and not final. It does not define {1} from {2}.
javac.err.new.intf=\
	{0} is an interface. It can''t be instantiated.
javac.err.invoke.abstract=\
	Can''t directly invoke abstract method {0} in {1}.
javac.err.unmatched.meth=\
	No method matching {0} found in {1}.
javac.err.unmatched.constr=\
	No constructor matching {0} found in {1}.
javac.err.wrong.number.args=\
	Wrong number of arguments in {0}.
javac.err.wrong.number.args=\
	Wrong number of arguments in {0}.
javac.err.forward.ref=\
	Can''t make forward reference to {0} in {1}.
javac.err.array.dim.missing=\
	Array dimension missing.
javac.err.new.abstract=\
	{0} is an abstract class. It can''t be instantiated.
javac.err.label.not.found=\
	No label definition found for {0}.
javac.err.invalid.break=\
	''break'' must be in loop or switch.
javac.err.invalid.continue=\
	''continue'' must be in loop.
javac.err.branch.to.uplevel=\
	a ''break'' or ''continue'' must transfer control within the same method.
javac.err.invalid.decl=\
	Invalid declaration.
javac.err.return.with.value=\
	''return'' with value from {0}.
javac.err.return.without.value=\
	''return'' without value from {0}.
javac.err.return.inside.static.initializer=\
	''return'' inside static initializer.
javac.err.invalid.label=\
	Invalid label.
javac.err.return.required.at.end=\
	Return required at end of {0}.
javac.err.duplicate.label=\
	Duplicate case label: {0}
javac.err.switch.overflow=\
	Case label {0} too large for ''switch'' on {1}
javac.err.const.expr.required=\
	Constant expression required.
javac.err.duplicate.default=\
	Duplicate ''default'' label.
javac.err.not.supported=\
	''{0}'' not supported.
javac.err.return.with.value.constr=\
	''return'' with value from constructor: {0}
javac.err.package.repeated=\
	Only one package declaration allowed.
javac.err.class.multidef=\
	Class {0} already defined in {1}.
javac.err.class.multidef.import=\
	Class name {0} clashes with imported class {1}.
javac.err.final.meth.override=\
	Final methods can''t be overriden. Method {0} is final in {1}.
javac.err.redef.return.type=\
	Method redefined with different return type: {0} was {1}
javac.err.override.static.meth=\
	Static methods can''t be overridden. Method {0} is static in {1}.
javac.err.override.instance.method.static=\
        Instance methods can''t be overridden by a static method.\nMethod {0} is an instance method in {1}.
javac.err.override.public=\
	Methods can''t be overridden to be more private. Method {0} is public in {1}.
javac.err.override.protected=\
	Methods can''t be overridden to be more private. Method {0} is protected in {1}.
javac.err.override.private=\
	Methods can''t be overridden to be more private. Method {0} is not private in {1}.
javac.err.intf.constructor=\
	Interfaces can''t have constructors.
javac.err.constr.modifier=\
	Constructors can''t be native, abstract, static, synchronized, or final: {0}
javac.err.intf.initializer=\
	Interfaces can''t have static initializers.
javac.err.intf.modifier.method=\
	Interface methods can''t be native, static, synchronized, final, private, or protected : {0}
javac.err.intf.modifier.field=\
	Interface fields can''t be private or protected: {0}
javac.err.transient.meth=\
	Method {0} can''t be transient. Only variables can be transient.
javac.err.volatile.meth=\
	Method {0} can''t be volatile. Only variables can be volatile.
javac.err.static.modifier=\
	Static methods can''t be abstract: {0}
javac.err.invalid.meth.body=\
	Abstract and native methods can''t have a body: {0}
javac.err.var.modifier=\
	Variables can''t be synchronized, abstract or native: {0}
javac.err.inner.modifier=\
	Inner classes can''t be volatile, transient, native, or synchronized: {0}
javac.err.transient.modifier=\
	Transient variables can''t be members of interfaces: {0}
javac.err.volatile.modifier=\
	Volatile variables can''t be final or members of interfaces: {0}
javac.err.initializer.needed=\
	This final variable must be initialized: {0}
javac.err.meth.multidef=\
	Duplicate method declaration: {0}
javac.err.meth.redef.rettype=\
	Methods can''t be redefined with a different return type: {0} was {1}
javac.err.var.multidef=\
	Duplicate variable declaration: {0} was {1}
javac.err.inner.class.multidef=\
	Duplicate inner class declaration: {0} is already defined in this scope.
javac.err.intf.super.class=\
	Superclass of {0} can''t be an interface: {1}
javac.err.cant.access.class=\
	Can''t access {0}. Only public classes and interfaces in other packages can be accessed.
javac.err.repeated.modifier=\
	Repeated modifier.
javac.err.inconsistent.modifier=\
	Inconsistent member declaration. At most one of public, private, or protected may be specified.
javac.err.super.is.final=\
	Can''t subclass final classes: {0}
javac.err.super.is.intf=\
	Can''t subclass interfaces: {0}
javac.err.cyclic.super=\
	Cyclic class inheritance.
javac.err.super.is.inner=\
	Cyclic class inheritance:  A subclass cannot enclose a superclass.
javac.err.cyclic.intf=\
	Cyclic interface inheritance.
javac.err.cyclic.scoping=\
	Cyclic class inheritance or scoping.
javac.err.not.intf=\
	{0} must be an interface.
javac.err.final.intf=\
	Interfaces can''t be final: {0}
javac.err.intf.impl.intf=\
	An interface can''t implement anything; it can only extend other interfaces.
javac.err.multiple.inherit=\
	Multiple inheritance is not supported.
javac.err.intf.repeated=\
	Interface {0} repeated.
javac.err.class.format=\
	Invalid class file format: {0}, {1}
javac.err.no.meth.body=\
	Method {0} requires a method body. Otherwise declare it as abstract.
javac.err.no.constructor.body=\
	Constructor {0} requires a method body.
javac.err.void.inst.var=\
	Instance variables can''t be void: {0}
javac.err.invalid.method.decl=\
	Invalid method declaration; return type required.
javac.err.invalid.method.decl.name=\
	Invalid method declaration; method name required.
javac.err.invalid.method.decl.qual=\
	Invalid qualified constructor name.
javac.err.super.not.found=\
	Superclass {0} of {1} not found.
javac.err.intf.not.found=\
	Interface {0} of {1} not found.
javac.err.final.abstract=\
        Class {0} can''t be declared both abstract and final.
javac.err.void.argument=\
	Argument can''t have type void: {0}
javac.err.invalid.expr=\
	Invalid expression statement.
javac.err.catch.not.reached=\
	catch not reached.
javac.err.stat.not.reached=\
	Statement not reached.
javac.err.arithmetic.exception=\
	Arithmetic exception.
javac.err.generic=\
	{0}
javac.err.public.class.file=\
	Public {0} must be defined in a file called "{1}".
javac.err.package.class.file=\
	{0} is defined in {1}. Because it is used outside of its source file, it should be defined in a file called "{2}".
javac.err.lose.precision=\
	Possible loss of precision. Use an explicit cast to convert {0} to {1}.
javac.err.duplicate.argument=\
	Variable ''{0}'' is used twice in the argument list of this method.
javac.err.local.redefined=\
	Variable ''{0}'' is already defined in this method.
javac.err.local.class.redefined=\
	Local class ''{0}'' is already defined in this method.
javac.err.inner.redefined=\
	The class name ''{0}'' is already defined in this scope.  An inner class may not have the same simple name as any of its enclosing classes.
javac.err.inherited.hides.field=\
	Variable ''{0}'' is inherited in {1}, and hides a variable of the same name in {2}. An explicit ''this'' qualifier must be used to select the desired instance.
javac.err.inherited.hides.local=\
	Variable ''{0}'' is inherited in {1}, and hides a local variable of the same name. An explicit ''this'' qualifier must be used to select the variable, or the local must be renamed.
javac.err.inherited.hides.method=\
	Method ''{0}'' is inherited in {1}, and hides a method of the same name in {2}. An explicit ''this'' qualifier must be used to select the desired instance.
javac.err.inherited.hides.type=\
	Type ''{0}'' is inherited in {1}, and hides a type of the same name in an enclosing scope. An explicit qualifier prefix must be used to name this type.
javac.err.private.class=\
	The type {0} can''t be private. Package members are always accessible within the current package.
javac.err.static.class=\
	The type {0} can''t be declared static. It is already top-level, since it is a member of a package.
javac.err.protected.class=\
	The type {0} can''t be made protected. Package members can either be public or local to the current package.
javac.err.recursive.constr=\
	Recursive constructor invocation: {0}.
javac.err.wrong.class=\
	File {0} does not contain {1} as expected, but {2}. Please remove the file, or make sure it appears in the correct subdirectory of the class path.
javac.err.wrong.source=\
	File {0} does not contain {1} as expected. Please adjust the class path so that the file does not appear in the {2}.
javac.err.class.not.found=\
	Class {0} not found in {1}.
javac.err.package.not.found=\
	Package {0} not found in {1}.
javac.err.illegal.mangled.name=\
	Invalid name {0} for {1}.
javac.err.class.and.package=\
	Ambiguous name: {0} is both a class and a package.
javac.err.invalid.throws=\
	Invalid exception {0} in throws clause. The exception must be a subclass of an exception thrown by {1} from {2}.
javac.err.throws.not.throwable=\
	{0} in throws clause must be a subclass of class java.lang.Throwable.
javac.err.throw.not.throwable=\
	Can''t throw {0}; it must be a subclass of class java.lang.Throwable.
javac.err.catch.not.throwable=\
	Can''t catch {0}; it must be a subclass of class java.lang.Throwable.
javac.err.initializer.exception=\
	Exception {0} can''t be thrown in initializer.
javac.err.cant.read=\
	Can''t read: {0}
javac.err.cant.write=\
	Can''t write: {0}
javac.err.fatal.error=\
	An error has occurred in the compiler; please file a bug report (http://java.sun.com/cgi-bin/bugreport.cgi).
javac.err.fatal.exception=\
	An exception has occurred in the compiler; please file a bug report (http://java.sun.com/cgi-bin/bugreport.cgi).
javac.err.no.inner.classes=\
	Support for inner classes has been disabled.
javac.err.uncaught.exception=\
	Exception {0} must be caught, or it must be declared in the throws clause of this method.
javac.err.catch.not.thrown=\
	Exception {0} is never thrown in the body of the corresponding try statement.
#warning:
javac.err.array.clone.supported=\
	Note: The cloning of an array does not throw any checked exceptions, and therefore does not require any catch clauses.  Please remove unused catch clauses, or if you wish to retain compatibility with older compilers, you may insert an artificial throw as follows:  if (false) throw new CloneNotSupportedException();
javac.err.no.outer.arg=\
	No enclosing instance of {0} is in scope; \
	an explicit one must be provided when creating {1}, \
	as in "outer. new Inner()" or "outer. super()".
javac.err.no.default.outer.arg=\
	No enclosing instance of {0} is in scope; \
	cannot create a default constructor for {1}.
javac.err.no.outer.base=\
	No enclosing instance of {0} is in scope; \
	an explicit one must be provided when accessing {1}, \
	as in "outer.member".
javac.err.static.inner.class=\
	The type {0} can''t be static.  Static members can only occur in interfaces and top-level classes.
javac.err.static.inner.field=\
	Variable {0} can''t be static in {1}.  Only members of interfaces and top-level classes can be static.
javac.err.static.inner.method=\
	Method {0} can''t be static in {1}.  Only members of interfaces and top-level classes can be static.
javac.err.too.many.errors=\
	Too many errors.  (The limit on reported errors is {0}.)
#
benv.parsed_in=[parsed {0} in {1} ms]
benv.loaded_in=[loaded {0} in {1} ms]
benv.failed_to_close_class_path=failed to close class path: {0}
main.usage=use: {0} [-g][-O][-debug][-depend][-nowarn][-verbose][-classpath path][-nowrite][-deprecation][-d dir][-J<runtime flag>] file.java...
main.wrote=[wrote {0}]
main.errors={0} errors
main.1error=1 error
main.warnings={0} warnings
main.1warning=1 warning
main.done_in=[done in {0} ms]
javac.err.invalid.encoding.char=\
	The source file encoding may be different with this platform encoding. Please use -encoding option to adjust file encoding, or apply native2ascii utility to make source file ASCII encoding.
