/*
	Lamp Example Unum

	Remember when you would play with a two-way switch connected to a common
	lamp? You would flick one switch and your sibbling would flick the other,
	turning the light on and off. This example creates an unum that represents
	such a circuit.

	Two or more stations on the net can share a lamp unum. Whenever any station
	types a return charater on the console, the state of the lamp is toggled - and
	a report of the new state is printed on everyone's terminal.

	This example does not gracefully handle a station disconnecting.
*/

// A lamp unum has one message, a request to toggle.
	export unit light {

	package ec.plexamples.light;

	import ec.plgen.*;

    	export interface LightUnum_if {
   		toggle();
	}

// Presences respond to notifications from other presences about changes
// in the lamps state, as well as the addition of new "switches".
	export interface LightPresence_if{
    	relayToggle();
    	notifyNewSwitch(Presence theSwitch);
	}

// Kind declarations for unum, presence, and ingredient.
    export unumKind Light_uk {
        interface LightUnum_if;
    }

    presenceKind Light_pk {
        interface LightPresence_if;
        state Common {
            boolean switchState;  // state of the lamp.
            Vector multicastList; // list of all other presences of this unum.
        }
    }

// Since there is only a single ingredient, we must declare it to handle
// both unum and presence messages.
    ingredientKind Light_ik {
        interface LightPresence_if;
        interface LightUnum_if;
    }

// This declaration explains how the presence is to be constructed
// and how unum and presence messages are to routed to ingredients.
    presenceStructure Light_ps {
        presenceKind Light_pk;
        ingredient Light ingredientKind Light_ik;
        deliver unum default to Light;
        deliver presence default to Light;
    }

// Most of the protocol is handled by the Light ingredient implementation
    ingredientImpl Light_ii {
        ingredientKind Light_ik;
		implements EInputHandler;	// EInputHandler is an interface to react to console input.

		state {
			RtRegistration myRegistration;	// Registration data for the prime presence only.
		}

		// State shared among presences
        state LightCommonState {
            boolean switchState;	// state of the lamp.
            Vector multicastList;	// list of all other presences of this unum.
        }

		// Handle a request to toggle the state of the lamp (generated by a UI event).
        method toggle() {
        	switchState = !switchState;
        	Enumeration en = multicastList.elements();
        	while (en.hasMoreElements()) {
        		Presence other = (Presence) en.nextElement();
        		other <- relayToggle();
        	}

            System.out.println("lamp is now: " + switchState);
        }

		// Handle a notification of a state change received from another presence.
        method relayToggle() {
        	switchState = !switchState;
            System.out.println("lamp is now: " + switchState);
        }

		// Add a presence to the local multicast list of other presences.
		method notifyNewSwitch(Presence theSwitch) {
			multicastList.addElement(theSwitch);
		}

		// The local user typed a newline character - so toggle the lamp.
		method handleInput(String line) {
			thisUnum <- toggle();
		}

		// Constructor method to generate a prime presence of a lamp unum.
        method constructLampMain(RtEEnvironment env, String name, String EARL) {
            try {
                 // Create the initial, empty multicast list.
                multicastList = new Vector();
           
            	// Create a registration so others can look us up.
                myRegistration = env.getRegistrar().register(name, thisUnum);
                System.out.println("A lamp now exists");
 
                // Connect to the console to receive notifications when input happens.
                RtConsole.setupConsoleReader(this, System.in, System.out);
            } catch (Exception e) {
                System.out.println("Error registering presence " + EARL + " :" + e);
            }
        }

        method constructReplica(Presence myParent) {
            try {
            	// Update the multicast lists to include me. Since
            	// the list I was created with includes everyone but me and
            	// the presence I was spawned from, we have to do a little bookkeeping...
            	// Add my parent to my multicast list.
            	thisPresence <- notifyNewSwitch(myParent);
            	// Tell the presence I was based on about my birth.
            	myParent <- notifyNewSwitch(thisPresence);
 
 				// Tell all the others that I have beena added.
            	Enumeration en = multicastList.elements();
        		while (en.hasMoreElements()) {
        			Presence other = (Presence) en.nextElement();
        			other <- notifyNewSwitch(thisPresence);
        		}

                System.out.println("A replica now exists");
                // Connect to the console to receive notifications when input happens.
                 RtConsole.setupConsoleReader(this, System.in, System.out);
           } catch (Exception e) {
                //System.out.println("Error registering presence " + EARL + " :" + e);
            }
        }
    }

	// Template for ingredient specification
    template Light_tmpl {
        ingredientImpl Light_ii;
        map state LightCommonState to Common;
    }

	// Description of the Light's presence implementation:
    presenceImpl Light_pi {
        presenceStructure Light_ps;	// Structure of the presence
        
  		// Initialization of prime and subsidary presences:
        prime init(RtEEnvironment env, String name, String EARL){
            Light <- constructLampMain(env, name, EARL);
        }
        
        init () {
        	Light <- constructReplica(otherPresence);
        }

        ingredient Light template Light_tmpl;	// and our one and only ingredient
    }

	// Finally, we declare the structure and implementation information for our unum:
    unumStructure Light_us {
        unumKind Light_uk;
        prime LightP makes LightP presenceKind Light_pk;
    }

    unumImpl Light_ui {
        unumStructure Light_us;
        presence LightP presenceImpl Light_pi;
    }
}
