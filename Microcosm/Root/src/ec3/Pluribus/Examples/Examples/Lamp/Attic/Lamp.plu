/*
  Lamp Example Unum

  Remember when you would play with a two-way switch connected to a common
  lamp? You would flick one switch and your sibling would flick the other,
  turning the light on and off. This example creates an unum that represents
  such a circuit.

  Two or more stations on the net can share a lamp unum. Whenever any station
  types a return charater on the console, the state of the lamp is toggled - and
  a report of the new state is printed on everyone's terminal.

*/

// A lamp unum has one message, a request to toggle.
  export unit Lamp {

  package ec.pl.examples.lamp;

  import ec.pl.runtime.*;
  import ec.ifc.codable.WorldObjectState;
    import ec.e.net.EPublisher;
    import ec.e.net.EPublication;

// Kind declarations for unum, presence, and ingredient.
    export kind Lamp_uk {
      toggle();
      transfer();
      setupUI(LampController controller);
    }

// Presences respond to notifications from other presences about changes
// in the lamps state, as well as the addition of new "switches".
    kind Lamp_pk {
      hostToggle();
      hostTransfer();
      relayToggle(boolean newSwitchState);
    }

// Since there is only a single ingredient, we must declare it to handle
// both unum and presence messages.
    kind Lamp_ik {
      kind Lamp_pk;
      kind Lamp_uk;
      init (LampState ls);
    }

// This declaration explains how the presence is to be constructed
// and how unum and presence messages are to routed to ingredients.
    presence Structure Lamp_ps {
        kind Lamp_pk;
        ingredient Lamp {
    kind Lamp_ik;
    //    deliver unum default;
    deliver unum toggle;
    deliver unum transfer;
    deliver unum setupUI;
    deliver presence Lamp_pk;
  }
    }

// Most of the protocol is handled by the Lamp ingredient implementation
    ingredient Impl Lamp_ii {
        kind Lamp_ik;
    implements PresenceDelegate;  // Has PresenceDelegate methods
    implements LampPeer;      // Handles UI

    // State shared among presences
    LampState lampState;   // State of the lamp

    LampController controller;

    function  public LampState getLampState() {
  return lampState;
    }

    init (LampState ls) {
        lampState = ls;
    }

        method hostTransfer() {
          int index;
          PresenceInterface pif = (PresenceInterface)(environment.presence);
          Presence p = (Presence)pif.presenceCorrespondingToHostForUnum(environment.unum);
          int size = environment.otherPresences.size();
          if (size > 0) {
            index = (int)System.currentTimeMillis();
            if (index < 0) index = -index;
            index = index % size;
            Presence pres = (Presence)environment.otherPresences.elementAt(index);
            controller.postStatus("Transferring host authority");
            pif.setNewHost((Presence_$_Intf)pres);
          }
          else {
            controller.postStatus("No other presence to transfer host authority to");
          }
        }

    // Handle a request to toggle the state of the lamp (generated by a UI event).
        method hostToggle() {
          lampState.switchState = !lampState.switchState;
      RtEnvelope env;
      env <- (kind Lamp_pk).relayToggle(lampState.switchState);
      BasePresence.sendEnvelopeToOthers(environment.otherPresences, env);
      showLampStatus();
        }

        function void showHostStatus () {
            if ((environment.flags & PresenceEnvironment.IsClientPresence) != 0) {
              controller.postEvent(LampController.EVENT_HOST_STATE, false);
            }
      else {
              controller.postEvent(LampController.EVENT_HOST_STATE, true);
      }
    }

    function void showLampStatus () {
      controller.postEvent(LampController.EVENT_LAMP_STATE, lampState.switchState);
    }

    method setupUI(LampController controller) {
      boolean hostState = ((environment.flags & PresenceEnvironment.IsClientPresence) == 0);
          this.controller = controller;
          controller.setPeer(this, hostState, lampState.switchState);
       }

        method lampToggle() {
          toggle();
        }

        method lampTransfer() {
          transfer();
        }

        method lampArchive() {
          WorldObjectState objs[] = new WorldObjectState[1];
          objs[0] = lampState;
          WorldObjectState.archiveObjectsToFile(lampState.name, objs);
        }

        method toggle() {
          if ((environment.flags & PresenceEnvironment.IsClientPresence) != 0) {
            environment.hostPresence <- (kind Lamp_pk).hostToggle();
          }
          else {
            hostToggle();
          }
        }

        method transfer() {
          if ((environment.flags & PresenceEnvironment.IsClientPresence) != 0) {
            environment.hostPresence <- (kind Lamp_pk).hostTransfer();
          }
          else {
            hostTransfer();
          }
        }

    // Handle a notification of a state change received from another presence.
        method relayToggle(boolean newSwitchState) {
          lampState.switchState = newSwitchState;
      showLampStatus();
        }

    method hostTransferOccured (int type) {
      if ((environment.flags & PresenceEnvironment.IsClientPresence) != 0) {
        environment.flags |= PresenceEnvironment.DieWhenNoOtherPresences;
      }
      else {
        environment.flags &= ~PresenceEnvironment.DieWhenNoOtherPresences;
      }
      showHostStatus();
    }

    method unumDeathNotification() {
      System.exit(0); // Windows has bugs which prevent clean shutdown
      ////Agency.getTheAgency().shutdown();
    }

    // Constructor method to generate a prime presence of a lamp unum.
        method constructLampMain(EEnvironment env) {
            lampState = (LampState)environment.worldState;
            try {
        EPublisher publisher = (EPublisher)env.get("publisher.root");
                EPublication pub = publisher.publish(lampState.name, environment.unum);
                String who = pub.getURL();
                String fileName = env.getProperty("EARLFile");
                if (fileName != null) {
                  RtUtil.writeStringInFile(who, fileName);
          System.out.println("Wrote URL into file " + fileName);
        }
        else {
          System.out.println("Lamp URL who=" + who);
        }
            } catch (Exception e) {
                System.out.println("Error registering presence " + lampState.name + ": " + e);
            }
        }

        method constructReplica() {
        }
    }

  // Description of the Lamp's presence implementation:
    presence Impl Lamp_pi {
        Structure Lamp_ps;  // Structure of the presence
    presenceBehavior IsClientPresence, TrackOtherPresences;

      // Initialization of prime presences
        prime init (EEnvironment env, LampState lampState) {
          setPresenceDelegate(Lamp);
          environment.worldState = lampState;
            Lamp <- constructLampMain(env);
          environment.flags &= ~PresenceEnvironment.IsClientPresence;
        }

      // Initialization of subsidiary presences
        init (LampState ls) {
          (ingredient Lamp).init(ls);
          setPresenceDelegate(Lamp);
          environment.flags |= PresenceEnvironment.DieWhenNoOtherPresences;
          environment.flags &= ~PresenceEnvironment.TrackOtherPresences;
          Lamp <- constructReplica();
        }

  // and our one and only ingredient
        ingredient Lamp template {
      Impl Lamp_ii;
  }
  
  // How to make new presences
  make LampP Lamp.getLampState();
    }

  // Finally, we declare the structure and implementation information for our unum:
    unum Structure Lamp_us {
        kind Lamp_uk;
        presence LampP kind Lamp_pk makes LampP;
        prime LampP;
    }

    unum Impl Lamp_ui {
        Structure Lamp_us;
        presence LampP Impl Lamp_pi;
    }
}
