<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Thu Jul 24 15:45:43 PDT 1997 -->
<title>
  Class ec.e.rep.RepositoryFile
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-ec.e.rep.html">This Package</a>  <a href="Package-ec.e.rep.html">Previous</a>  <a href="Package-ec.e.rep.html">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class ec.e.rep.RepositoryFile
</h1>
<pre>
java.lang.Object
   |
   +----ec.e.rep.RepositoryFile
</pre>
<hr>
<dl>
  <dt> public class <b>RepositoryFile</b>
  <dt> extends Object
</dl>
A RepositoryFile contains encoded (Java) objects, encoded using
 Openers.  First in the RepositoryFile, in fixed file-positions,
 are some special-treated data in what is called the FileInfo
 block, such as the RepositoryFile Version number, and
 information that allow us to retrieve the keys for the file.<p>
 Each record in the file contains both the key and the data,
 encoded using Openers. This allows us to recover the keys in a
 file by reading the whole file sequentially. However, each file
 normally contains a hashtable of keys, that is stored at the
 end of the file. This hashtable is saved under the reserved key
 "%LocalKeyVector%", just to keep all data in the file conform
 to a key-data pairing scheme. Note that when we want to add
 more data to the file, which is done by appending, then we will
 overwrite this hashtable and will re-write it only when we
 close the file. The special information (in the beginning of
 the file) is updated to reflect this in such a way that it is
 never inconsistent (See below).<p>
<p>
<hr>
<a name="index"></a>
<h2>
  <img src="images/variable-index.gif" width=207 height=38 alt="Variable Index">
</h2>
<dl>
  <dt> <img src="images/blue-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#NO_COMPRESSION"><b>NO_COMPRESSION</b></a>
  <dd> 
  <dt> <img src="images/blue-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#REPOSITORYFILE_MAGIC_NUMBER"><b>REPOSITORYFILE_MAGIC_NUMBER</b></a>
  <dd> 
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#analyzeFile()"><b>analyzeFile</b></a>()
  <dd> 
 Analyze file sequentially and print out detailed information
 about every reccord in the file to EStdio.err()

 
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#close()"><b>close</b></a>()
  <dd> 
 Close this RepositoryFile.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#delete(java.lang.Object)"><b>delete</b></a>(Object)
  <dd> 
 Delete an object, given a key.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#deleteIfExists(java.lang.Object)"><b>deleteIfExists</b></a>(Object)
  <dd> 
 Quietly delete a record if it exists but don't throw if key
 doesn't exist.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#exists(java.lang.Object)"><b>exists</b></a>(Object)
  <dd> 
 Determine whether a record for a given key exists.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#flushChanges(boolean)"><b>flushChanges</b></a>(boolean)
  <dd> 

 Save out some info, possibly including our file-local keys
 hashtable (myKey) to the file.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#get(java.lang.Object, ec.e.rep.RtDecodingParameters)"><b>get</b></a>(Object, RtDecodingParameters)
  <dd> 
 Retrieve an object, given a key and a decoding parameter table.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#isWritable()"><b>isWritable</b></a>()
  <dd> 
 Tells whether this file is writable


  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#put(java.lang.Object, java.lang.Object)"><b>put</b></a>(Object, Object)
  <dd> 
 Save a data object under a given key.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#putHash(java.lang.Object)"><b>putHash</b></a>(Object)
  <dd> 
 Stores an object into the Repository using the cryptographic
 hash of the data as a key.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#repairFile(boolean, boolean)"><b>repairFile</b></a>(boolean, boolean)
  <dd> 
 Force a key regeneration and update file using the results

 
</dl>
<a name="variables"></a>
<h2>
  <img src="images/variables.gif" width=153 height=38 alt="Variables">
</h2>
<a name="REPOSITORYFILE_MAGIC_NUMBER"><img src="images/blue-ball.gif" width=12 height=12 alt=" o "></a>
<b>REPOSITORYFILE_MAGIC_NUMBER</b>
<pre>
 public static final long REPOSITORYFILE_MAGIC_NUMBER
</pre>
<a name="NO_COMPRESSION"><img src="images/blue-ball.gif" width=12 height=12 alt=" o "></a>
<b>NO_COMPRESSION</b>
<pre>
 public static final long NO_COMPRESSION
</pre>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="isWritable()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="isWritable"><b>isWritable</b></a>
<pre>
 public boolean isWritable()
</pre>
<dl>
  <dd> Tells whether this file is writable
<p>
</dl>
<a name="put(java.lang.Object, java.lang.Object)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="put"><b>put</b></a>
<pre>
 public RepositoryHandle put(Object key,
                             Object data) throws IOException, <a href="ec.e.rep.steward.RepositoryAccessException.html#_top_">RepositoryAccessException</a>
</pre>
<dl>
  <dd> Save a data object under a given key. The data is appended to
 the logical end of the RepositoryFile as indicated by
 myFileLength. Note that this may not be the actual end of file
 once the file is closed.  When we write the key hashtable to
 the file (before closing file) we will not update myFileLength
 since we don't regard the hashtable as part of the real
 data. But since the hashtable is of nonzero length, the file is
 actually longer than myFileLength indicates. <p>
 First we seek to the end of the file, then the length of the
 encoded key is written, then the encoded key. Then the
 length of the encoded data is written, then the enccoded data.
 The file pointer is left at the (new) end of the file, but this
 is not important since we actually don't trust it to stay
 there between calls. <p>
 A deleted record can cause one of two kinds of entries. An
 "empty" entry is an entry where the key has the length 0 and
 the data has the length of the deleted record and deleted key
 (so as to occupy the same number of bytes). <p>
 In contrast, a "Voided" entry has a normal key but the data are
 of length 0. These are used to shadow un-deleted and
 un-deletable entries in other repositoryfiles. <p>
 Note that deleting an existing record in the frontmost file
 smashes the existing record to "empty" first. After that we may
 or may not add a "Voided" entry to the end of the file, just as
 any regular record. We cannot just replace a record we are
 deleting with a voided one since the data length would not be 0
 and we need to always be able to skip a record, deleted or not,
 so we can read the file linearly in case we lose the hastable
 due to file corruption. <p>
 Note that we can tell the difference between a null stored in
 the database and a voided record. The real null is encoded to a
 non-empty byte array, whereas the voided record contains no
 data bytes at all. <p>
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> key - untrusted notNull - the key to store the data under.
    <dd> data - untrusted - the data to store. If null, then an
 explicit null is stored.
    <dt> <b>Returns:</b>
    <dd> RepositoryHandle - an object to retrieve the saved
 object by. These objects are typically stored in a hashtable by
 the caller under the same key as the one given to this method,
 and used to retrieve the object later. The local hashtable is
 maintained only so it can be written out to the file at closing
 or checkpointing time.
  </dl></dd>
</dl>
<a name="putHash(java.lang.Object)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="putHash"><b>putHash</b></a>
<pre>
 public CryptoHash putHash(Object data) throws IOException, <a href="ec.e.rep.steward.RepositoryAccessException.html#_top_">RepositoryAccessException</a>
</pre>
<dl>
  <dd> Stores an object into the Repository using the cryptographic
 hash of the data as a key.  It returns that key as an instance
 of class CryptoHash.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> data - suspect nullOK - The object to save in the
 Repository using an automatically generated key.
    <dt> <b>Returns:</b>
    <dd> The cryptographic hash of the data (an instance of
 class CryptoHash), that was used as the key to store the data
 under.
 <p><b>NOTE</b> If the data is null, then a special object, the
 nullCryptoHash object, is returned. This is treated as a
 special case since java hashtables cannot store null and the
 serializers store the data in hashtables to detect
 circularities.
  </dl></dd>
</dl>
<a name="get(java.lang.Object, ec.e.rep.RtDecodingParameters)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="get"><b>get</b></a>
<pre>
 public Object get(Object key,
                   <a href="ec.e.rep.RtDecodingParameters.html#_top_">RtDecodingParameters</a> parameters) throws IOException, <a href="ec.e.rep.steward.RepositoryKeyNotFoundException.html#_top_">RepositoryKeyNotFoundException</a>
</pre>
<dl>
  <dd> Retrieve an object, given a key and a decoding parameter table.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> key - notNull untrusted - An object to use as a key.
    <dd> parameters - nullOK untrusted - An RtDecodingParameters d table.
 <p><b>NOTE</b> XXX - we don't currently use the parameter table
 since Openers don't support it.
  </dl></dd>
</dl>
<a name="delete(java.lang.Object)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="delete"><b>delete</b></a>
<pre>
 public void delete(Object key) throws IOException, <a href="ec.e.rep.steward.RepositoryKeyNotFoundException.html#_top_">RepositoryKeyNotFoundException</a>
</pre>
<dl>
  <dd> Delete an object, given a key.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> key - notNull untrusted - An object to use as a key.
  </dl></dd>
</dl>
<a name="exists(java.lang.Object)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="exists"><b>exists</b></a>
<pre>
 public boolean exists(Object key)
</pre>
<dl>
  <dd> Determine whether a record for a given key exists.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> key - notNull untrusted - An object to use as a key.
  </dl></dd>
</dl>
<a name="deleteIfExists(java.lang.Object)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="deleteIfExists"><b>deleteIfExists</b></a>
<pre>
 public boolean deleteIfExists(Object key)
</pre>
<dl>
  <dd> Quietly delete a record if it exists but don't throw if key
 doesn't exist. Returs true if something was deleted.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> key - notNull untrusted - An object to use as a key.
  </dl></dd>
</dl>
<a name="close()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="close"><b>close</b></a>
<pre>
 public void close() throws IOException
</pre>
<dl>
  <dd> Close this RepositoryFile.  Flush the changes to the myKeys
 hashtable and the file info, then close the repository file.
<p>
</dl>
<a name="flushChanges(boolean)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="flushChanges"><b>flushChanges</b></a>
<pre>
 public void flushChanges(boolean saveEverything) throws IOException
</pre>
<dl>
  <dd> Save out some info, possibly including our file-local keys
 hashtable (myKey) to the file.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> saveEverything - - If set then we save out the keys
 hashtable also. If not set, then we save out only the more
 important fileinfo variables. The keys table can be recovered
 at startup time so it may make sense not to write it out except
 when quitting, and to accept the work of repairing the file if
 a crash happens.
  </dl></dd>
</dl>
<a name="repairFile(boolean, boolean)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="repairFile"><b>repairFile</b></a>
<pre>
 public void repairFile(boolean repairIt,
                        boolean report) throws IOException
</pre>
<dl>
  <dd> Force a key regeneration and update file using the results
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> report - - If set, also report what we find to
 EStdio.err
  </dl></dd>
</dl>
<a name="analyzeFile()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="analyzeFile"><b>analyzeFile</b></a>
<pre>
 public void analyzeFile() throws Exception
</pre>
<dl>
  <dd> Analyze file sequentially and print out detailed information
 about every reccord in the file to EStdio.err()
<p>
  <dd><dl>
    <dt> <b>Throws:</b> Exception
    <dd> - Throws many kinds of exceptions. This
 method is only intended to be called from non-runtime tools
 such as the Curator.
  </dl></dd>
</dl>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-ec.e.rep.html">This Package</a>  <a href="Package-ec.e.rep.html">Previous</a>  <a href="Package-ec.e.rep.html">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
